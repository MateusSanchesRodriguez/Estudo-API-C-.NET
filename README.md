# Projeto de Estudo em C# - API e Banco de Dados

Este projeto representa uma jornada de aprendizado focada no desenvolvimento em C#, especificamente na criação de APIs e na sua integração com bancos de dados. O objetivo principal foi aprofundar os conhecimentos práticos sobre como construir uma API funcional, conectá-la a um banco de dados de forma automatizada e aplicar boas práticas de desenvolvimento.

Durante a concepção e implementação deste projeto, explorei diversos conceitos fundamentais. Aprendi sobre a importância da estruturação de arquivos e pastas para manter um projeto legível e organizado, facilitando a manutenção e a colaboração. Um dos pontos cruciais foi entender o uso de Data Transfer Objects (DTOs), que se mostraram essenciais para desacoplar a representação interna dos dados (modelo do banco) daquela exposta pela API, uma prática recomendada para aumentar a segurança e a flexibilidade, evitando a exposição direta do modelo do banco em requisições POST e outras interações.

## Aprendizados Adquiridos

Ao longo deste módulo de estudo, consolidei diversos conhecimentos sobre o desenvolvimento de APIs com C#. Compreendi as vantagens inerentes ao uso de APIs, como a facilidade que proporcionam tanto para o consumo quanto para a disponibilização de dados, além da padronização que impõem nas integrações entre sistemas. O padrão arquitetural REST foi estudado como uma abordagem fundamental para padronizar o tráfego de dados, definindo convenções para as operações e representações de recursos. Percebi como as APIs são eficazes em abstrair detalhes complexos de implementação, oferecendo uma interface clara e bem definida para os consumidores.

O processo incluiu a preparação do ambiente de desenvolvimento tanto em Windows quanto em Linux, garantindo a capacidade de trabalhar em diferentes sistemas operacionais. Aprendi a enviar requisições para a API utilizando rotas padronizadas, um aspecto essencial para a comunicação cliente-servidor. A criação de controladores foi um passo importante para preparar a API para receber e processar essas requisições, direcionando-as para as lógicas de negócio apropriadas.

No que diz respeito à manipulação de dados, explorei a finalidade do verbo HTTP POST, utilizado especificamente para criar novos recursos no sistema. Inicialmente, pratiquei a criação de recursos em memória, utilizando listas, como uma forma de entender o fluxo básico antes de integrar com o banco de dados. Para garantir a integridade dos dados recebidos, aprendi a utilizar anotações de validação como `[Required]`, que torna um parâmetro obrigatório; `[StringLength]`, que limita o número de caracteres de uma string; e `[Range]`, que define um intervalo válido para valores numéricos.

Para a recuperação de informações, o foco foi no verbo GET, que tem como objetivo retornar recursos existentes na API. Aprendi a enviar parâmetros diretamente pela URL da requisição, permitindo consultas mais específicas. O uso de LINQ (Language Integrated Query) foi fundamental para filtrar os recursos de forma eficiente antes de retorná-los ao usuário, otimizando as consultas. Entendi também a importância dos códigos de status HTTP, como o 404 Not Found, que indica claramente quando um recurso solicitado não existe.

Visando otimizar as respostas da API, especialmente ao lidar com grandes volumes de dados, explorei conceitos de paginação. Aprendi a aplicar paginação de forma prática utilizando os métodos `Skip()` e `Take()` do LINQ, permitindo que os clientes requisitem dados em blocos menores e mais gerenciáveis, melhorando a performance e a experiência do usuário.

A integração com o banco de dados foi realizada utilizando o Entity Framework Core, uma ferramenta poderosa do ecossistema .NET. Aprendi a estabelecer a conexão entre a API e o banco de dados e a gerar *migrations*, que são essenciais para mapear os objetos C# (modelos) para as tabelas do banco de dados e gerenciar as alterações no esquema ao longo do tempo. O `DbContext` foi apresentado como a ponte principal para realizar operações no banco, encapsulando a sessão com o banco de dados. A injeção de dependência do `DbContext` nos controladores permitiu um acesso limpo e testável ao banco de dados. Para persistir as alterações realizadas (criação, atualização, exclusão), utilizei o método `SaveChanges()`.

Como mencionado anteriormente, os DTOs foram introduzidos como uma camada adicional para evitar a exposição direta dos modelos do banco de dados, melhorando a segurança e a flexibilidade da API. Para facilitar a conversão entre os modelos de domínio e os DTOs, utilizei o AutoMapper, uma biblioteca que automatiza mapeamentos entre diferentes tipos de objetos, tornando o código mais limpo e reduzindo a necessidade de conversões manuais repetitivas.

Explorei também os verbos HTTP para atualização e exclusão de recursos. O verbo PUT foi utilizado para atualizações completas de um recurso, onde o cliente envia a representação total do recurso atualizado. O verbo PATCH foi apresentado como uma alternativa para atualizações parciais, permitindo modificar apenas campos específicos de um recurso. Embora o PATCH ofereça mais flexibilidade ao cliente por não exigir o envio do objeto completo, sua implementação no servidor exige uma configuração mais complexa para lidar com as atualizações parciais de forma segura. Para a remoção de recursos, utilizei o verbo DELETE. Aprendi que, em operações de atualização (PUT/PATCH) ou remoção (DELETE) bem-sucedidas, é apropriado retornar o status HTTP 204 (No Content), indicando que a operação foi realizada com sucesso, mas não há conteúdo para retornar no corpo da resposta.

Finalmente, reconheci a importância crucial de documentar a API. Uma boa documentação é valiosa tanto para a equipe de desenvolvimento que mantém a API quanto para os desenvolvedores que irão consumi-la. Configurei o Swagger na classe `Program.cs` para gerar automaticamente uma documentação interativa da API. Aprendi também a enriquecer essa documentação utilizando comentários XML nos métodos dos controladores, fornecendo descrições detalhadas sobre as rotas, parâmetros esperados e possíveis retornos. O Swagger demonstrou ser uma ferramenta extremamente útil para facilitar o entendimento e o teste da API.
